---
title: "Using the 'jsoncons' Library in R"
author:
- name: Martin Morgan
  affiliation: Roswell Park Comprehensive Cancer Center, Buffalo, NY, US
- name: Marcel Ramos
  affiliation: CUNY School of Public Health at Hunter College, New York, NY, US
output:
  BiocStyle::html_document
vignette: |
  %\VignetteIndexEntry{Using the 'jsoncons' Library in R}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE
)
```

# Introduction & installation

This package provides the header-only '[jsoncons][]' library for
manipulating JSON objects. Use [rjsoncons][] for querying JSON or R
objects using [JMESpath][], [JSONpath][], or [JSONpointer][]. Link to
the package for direct access to the 'jsoncons' C++ library.

[jsoncons]: https://github.com/danielaparker/jsoncons/
[rjsoncons]: https://mtmorgan.github.io/rjsoncons/
[JSONpath]: https://goessner.net/articles/JsonPath/
[JMESpath]: https://jmespath.org/
[JSONpointer]: https://datatracker.ietf.org/doc/html/rfc6901

Install the released package version from CRAN

```{r, eval = FALSE}
install.pacakges("rjsoncons", repos = "https://CRAN.R-project.org")
```

Install the development version with

```{r, eval = FALSE}
if (!requireNamespace("remotes", quiety = TRUE))
    install.packages("remotes", repos = "https://CRAN.R-project.org")
remotes::install_github("mtmorgan/rjsoncons")
```

Attach the installed package to your *R* session, and check the
version of the C++ library in use

```{r, messages = FALSE}
library(rjsoncons)
rjsoncons::version()
```

# Use cases

## Select, filter and transform

Here is a simple JSON example document

```{r}
json <- '{
  "locations": [
    {"name": "Seattle", "state": "WA"},
    {"name": "New York", "state": "NY"},
    {"name": "Bellevue", "state": "WA"},
    {"name": "Olympia", "state": "WA"}
  ]
}'
```

There are several common use cases. Use [rjsoncons][] to query the
JSON string using [JSONpath][], [JMESPath][] or [JSONpointer][]
syntax to filter larger documents to records of interest, e.g., only
cities in New York state.

```{r}
jmespath(json, "locations[?state == 'NY']") |>
    cat("\n")
```

Use the `as = "R"` argument to extract deeply nested elements as *R*
objects, e.g., a character vector of city names in Washington state.

```{r}
jmespath(json, "locations[?state == 'WA'].name", as = "R")
```

The JSON Pointer specification is simpler, indexing a single object in
the document. JSON arrays are 0-based.

```{r jsonpointer}
jsonpointer(json, "/locations/0/state")
```

Additional examples illustrating features available are on the help
pages, e.g., `?jmespath`.

## Array-of-objects to *R* data.frame

The following transforms a nested JSON document into a format that can
be incorporated directly in *R* as a `data.frame`.

```{r}
path <- '{
    name: locations[].name,
    state: locations[].state
}'
jmespath(json, path, as = "R") |>
    data.frame()
```

The transformation from JSON 'array-of-objects' to 'object-of-arrays'
suitable for direct representation as a `data.frame` is common, and is
implemented directly as `jsonpivot()`

```{r jsonpivot}
json |>
    ## select the 'array-of-objects' portion of the JSON document
    jmespath("locations") |>
    ## pivot and return represenation as R named list-of-vectors
    jsonpivot(as = "R") |>
    ## coerce to data.frame, tibble, etc.
    data.frame()
```

[purrr]: https://CRAN.R-project.org/package=purrr
[tidyr]: https://CRAN.R-project.org/package=tidyr
[r4ds]: https://r4ds.hadley.nz/
[hierarchical data]: https://r4ds.hadley.nz/rectangling

## *R* objects as input

[rjsoncons][] can filter and transform _R_ objects. These are
converted to JSON using `jsonlite::toJSON()` before queries are made;
`toJSON()` arguments like `auto_unbox = TRUE` can be added to the
function call.

```{r}
## `lst` is an *R* list
lst <- jsonlite::fromJSON(json, simplifyVector = FALSE)
jmespath(lst, "locations[?state == 'WA'].name | sort(@)", auto_unbox = TRUE) |>
    cat("\n")
```

# The JSON parser

The package includes a JSON parser, used with the argument `as = "R"`
or directly with `as_r()`

``` r
as_r('{"a": 1.0, "b": [2, 3, 4]}') |>
    str()
#> List of 2
#>  $ a: num 1
#>  $ b: int [1:3] 2 3 4
```

The main rules of this transformation are outlined here.  JSON arrays
of a single type (boolean, integer, double, string) are transformed to
*R* vectors of the same length and corresponding type.

```{r}
as_r('[true, false, true]') # boolean -> logical
as_r('[1, 2, 3]')           # integer -> integer
as_r('[1.0, 2.0, 3.0]')     # double  -> numeric
as_r('["a", "b", "c"]')     # string  -> character
```

JSON arrays mixing integer and double values are transformed to
*R* numeric vectors.

```{r}
as_r('[1, 2.0]') |> class() # numeric
```

If a JSON integer array contains a value larger than *R*'s 32-bit
integer representation, the array is transformed to an *R* numeric
vector. NOTE that this results in loss of precision for JSON integer
values greater than `2^53`.

```{r}
as_r('[1, 2147483648]') |> class()  # 64-bit integers -> numeric
```

JSON objects are transformed to *R* named lists.

```{r}
as_r('{}')
as_r('{"a": 1.0, "b": [2, 3, 4]}') |> str()
```

There are several additional details. A JSON scalar and a JSON vector
of length 1 are represented in the same way in *R*.

```{r}
identical(as_r("3.14"), as_r("[3.14]"))
```

JSON arrays mixing types other than integer and double are transformed to
*R* lists

```{r}
as_r('[true, 1, "a"]') |> str()
```

JSON `null` values are represented as *R* `NULL` values; arrays of
`null` are transformed to lists

```{r}
as_r('null')                  # NULL
as_r('[null]') |> str()       # list(NULL)
as_r('[null, null]') |> str() # list(NULL, NULL)
```

Ordering of object members is controlled by the `object_names=`
argument. The default preserves names as they appear in the JSON
definition; use `"sort"` to sort names alphabetically. This argument
is applied recursively.

```{r}
json <- '{"b": 1, "a": {"d": 2, "c": 3}}'
as_r(json) |> str()
as_r(json, object_names = "sort") |> str()
```

The parser corresponds approximately to `jsonlite::fromJSON()` with
arguments `simplifyVector = TRUE, simplifyDataFrame = FALSE,
simplifyMatrix = FALSE)`. Unit tests (using the [tinytest][]
framework) providing additional details are available at

```{r, eval = FALSE}
system.file(package = "rjsoncons", "tinytest", "test_as_r.R")
```

[tinytest]: https://CRAN.R-project.org/package=tinytest

## Using `jsonlite::fromJSON()`

The built-in parser can be replaced by alternative parsers by returning
the query as a JSON string, e.g., using the `fromJSON()` in the
[jsonlite][] package.

```{r}
jmespath(json, "locations[?state == 'WA']", as  = "string") |>
    ## `fromJSON()` simplifies list-of-objects to data.frame
    jsonlite::fromJSON()
```

[jsonlite]: https://CRAN.R-project.org/package=jsonlite

The [rjsoncons][] package is particularly useful when accessing
elements that might otherwise require complicated application of
nested `lapply()`, [purrr][] expressions, or [tidyr][] `unnest_*()`
(see [R for Data Science][r4ds] chapter '[Hierarchical data][]').

# C++ library use in other packages

The package includes the complete 'jsoncons' C++ header-only library,
available to other R packages by adding

```
LinkingTo: rjsoncons
SystemRequirements: C++11
```

to the DESCRIPTION file. Typical use in an R package would also
include `LinkingTo:` specifications for the [cpp11][] or [Rcpp][]
(this package uses [cpp11][]) packages to provide a C / C++ interface
between R and the C++ 'jsoncons' library.

[cpp11]: https://cran.r-project.org/package=cpp11
[Rcpp]: https://cran.r-project.org/package=Rcpp

# Session information

This vignette was compiled using the following software versions

```{r}
sessionInfo()
```
