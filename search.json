[{"path":"https://mtmorgan.github.io/rjsoncons/articles/a_rjsoncons.html","id":"introduction-installation","dir":"Articles","previous_headings":"","what":"Introduction & installation","title":"Using 'jsoncons' in R","text":"package provides header-‘jsoncons’ library manipulating JSON objects. Use rjsoncons querying JSON R objects using JMESpath, JSONpath, JSONpointer. Link package direct access ‘jsoncons’ C++ library. Install released package version CRAN Install development version Attach installed package R session, check version C++ library use","code":"install.packages(\"rjsoncons\", repos = \"https://CRAN.R-project.org\") if (!requireNamespace(\"remotes\", quiety = TRUE))     install.packages(\"remotes\", repos = \"https://CRAN.R-project.org\") remotes::install_github(\"mtmorgan/rjsoncons\") library(rjsoncons) rjsoncons::version() ## [1] \"0.173.2\""},{"path":[]},{"path":"https://mtmorgan.github.io/rjsoncons/articles/a_rjsoncons.html","id":"select-filter-and-transform-with-j_query","dir":"Articles","previous_headings":"JSON Use cases","what":"Select, filter and transform with j_query()","title":"Using 'jsoncons' in R","text":"simple JSON example document several common use cases. Use rjsoncons query JSON string using JSONpath, JMESpath JSONpointer syntax filter larger documents records interest, e.g., cities New York state, using ‘JMESpath’ syntax. Use = \"R\" argument extract deeply nested elements R objects, e.g., character vector city names Washington state. JSON Pointer specification simpler, indexing single object document. JSON arrays 0-based. examples use j_query(), automatically infers query specification form path using j_path_type(). may useful indicate query specification explicitly using jsonpointer(), jsonpath(), jmespath(); examples illustrating features available query specification help pages ?jsonpointer, ?jsonpath, ?jmespath.","code":"json <- '{   \"locations\": [     {\"name\": \"Seattle\", \"state\": \"WA\"},     {\"name\": \"New York\", \"state\": \"NY\"},     {\"name\": \"Bellevue\", \"state\": \"WA\"},     {\"name\": \"Olympia\", \"state\": \"WA\"}   ] }' j_query(json, \"locations[?state == 'NY']\") |>     cat(\"\\n\") ## [{\"name\":\"New York\",\"state\":\"NY\"}] j_query(json, \"locations[?state == 'WA'].name\", as = \"R\") ## [1] \"Seattle\"  \"Bellevue\" \"Olympia\" j_query(json, \"/locations/0/state\") ## [1] \"WA\""},{"path":"https://mtmorgan.github.io/rjsoncons/articles/a_rjsoncons.html","id":"array-of-objects-to-r-data-frame-with-j_pivot","dir":"Articles","previous_headings":"JSON Use cases","what":"Array-of-objects to R data.frame with j_pivot()","title":"Using 'jsoncons' in R","text":"following transforms nested JSON document format can incorporated directly R data.frame. transformation JSON ‘array--objects’ ‘object--arrays’ suitable direct representation data.frame common, implemented directly j_pivot() j_pivot() also support = \"tibble\" dplyr package installed.","code":"path <- '{     name: locations[].name,     state: locations[].state }' j_query(json, path, as = \"R\") |>     data.frame() ##       name state ## 1  Seattle    WA ## 2 New York    NY ## 3 Bellevue    WA ## 4  Olympia    WA j_pivot(json, \"locations\", as = \"data.frame\") ##       name state ## 1  Seattle    WA ## 2 New York    NY ## 3 Bellevue    WA ## 4  Olympia    WA"},{"path":"https://mtmorgan.github.io/rjsoncons/articles/a_rjsoncons.html","id":"r-objects-as-input","dir":"Articles","previous_headings":"JSON Use cases","what":"R objects as input","title":"Using 'jsoncons' in R","text":"rjsoncons can filter transform R objects. converted JSON using jsonlite::toJSON() queries made; toJSON() arguments like auto_unbox = TRUE can added function call.","code":"## `lst` is an *R* list lst <- jsonlite::fromJSON(json, simplifyVector = FALSE) j_query(lst, \"locations[?state == 'WA'].name | sort(@)\", auto_unbox = TRUE) |>     cat(\"\\n\") ## [\"Bellevue\",\"Olympia\",\"Seattle\"]"},{"path":"https://mtmorgan.github.io/rjsoncons/articles/a_rjsoncons.html","id":"ndjson-support","dir":"Articles","previous_headings":"","what":"NDJSON support","title":"Using 'jsoncons' in R","text":"rjsoncons supports NDJSON (new-line delimited JSON). NDJSON consists file character vector line / element represents JSON record. example uses data GitHub Archive project recording actions public GitHub repositories. data included package first 10 lines https://data.gharchive.org/2023-02-08-0.json.gz. NDJSON can read R (ndjson <- readLines(ndjson_file)) used j_query() / j_pivot(), often better leave full NDJSON files disk. Thus first argument j_query() j_pivot() usually (text gz-compressed) file path URL. Two additional options available working NDJSON. n_records limits number records processed. Using n_records can useful exploring data. instance, first record file can viewed interactively option verbose = TRUE adds progress indicator, provides confidence progress made parsing large files. progress bar requires cli package. j_query() provides one--one mapping NDJSON lines / elements return value, e.g., j_query(ndjson_file, \"@\", = \"string\") NDJSON file 1000 lines return character vector 1000 elements, j_query(ndjson, \"@\", = \"R\") R list length 1000. j_pivot() transforms NDJSON file character vector objects format convenient input R. j_pivot() NDJSON files JMESpath paths work particularly well together, JMESpath provides flexibility creating JSON objects pivoted. Filtering NDJSON files can require relatively complicated paths, e.g., filter ‘PushEvent’ types organizations, construct query acts NDJSON record return array single object, apply filter replace uninteresting elements 0-length arrays (using = \"tibble\" often transforms R list--vectors tibble pleasing robust manner compared = \"data.frame\"). complete example used NDJSON extended vignette","code":"ndjson_file <-     system.file(package = \"rjsoncons\", \"extdata\", \"2023-02-08-0.json\") j_query(ndjson_file, n_records = 1) |>     listviewer::jsonedit() j_query(ndjson_file, \"{id: id, type: type}\", n_records = 5) ## [1] \"{\\\"id\\\":\\\"26939254345\\\",\\\"type\\\":\\\"DeleteEvent\\\"}\" ## [2] \"{\\\"id\\\":\\\"26939254358\\\",\\\"type\\\":\\\"PushEvent\\\"}\"   ## [3] \"{\\\"id\\\":\\\"26939254361\\\",\\\"type\\\":\\\"CreateEvent\\\"}\" ## [4] \"{\\\"id\\\":\\\"26939254365\\\",\\\"type\\\":\\\"CreateEvent\\\"}\" ## [5] \"{\\\"id\\\":\\\"26939254366\\\",\\\"type\\\":\\\"PushEvent\\\"}\" j_pivot(ndjson_file, \"{id: id, type: type}\", as = \"data.frame\") ##             id        type ## 1  26939254345 DeleteEvent ## 2  26939254358   PushEvent ## 3  26939254361 CreateEvent ## 4  26939254365 CreateEvent ## 5  26939254366   PushEvent ## 6  26939254367   PushEvent ## 7  26939254379   PushEvent ## 8  26939254380 IssuesEvent ## 9  26939254382   PushEvent ## 10 26939254383   PushEvent path <-     \"[{id: id, type: type, org: org}]          [?@.type == 'PushEvent' && @.org != null]\" j_pivot(ndjson_file, path, as = \"data.frame\") ##            id      type    org.id          org.login org.gravatar_id ## 1 26939254358 PushEvent 123667276 johnbieren-testing                 ## 2 26939254382 PushEvent 123667276 johnbieren-testing                 ##                                          org.url ## 1 https://api.github.com/orgs/johnbieren-testing ## 2 https://api.github.com/orgs/johnbieren-testing ##                                       org.avatar_url  org.id.1  org.login.1 ## 1 https://avatars.githubusercontent.com/u/123667276? 120284018 mornystannit ## 2 https://avatars.githubusercontent.com/u/123667276? 120284018 mornystannit ##   org.gravatar_id.1                                org.url.1 ## 1                   https://api.github.com/orgs/mornystannit ## 2                   https://api.github.com/orgs/mornystannit ##                                     org.avatar_url.1 ## 1 https://avatars.githubusercontent.com/u/120284018? ## 2 https://avatars.githubusercontent.com/u/120284018?"},{"path":"https://mtmorgan.github.io/rjsoncons/articles/a_rjsoncons.html","id":"the-json-parser","dir":"Articles","previous_headings":"","what":"The JSON parser","title":"Using 'jsoncons' in R","text":"package includes JSON parser, used argument = \"R\" directly as_r() main rules transformation outlined . JSON arrays single type (boolean, integer, double, string) transformed R vectors length corresponding type. JSON arrays mixing integer double values transformed R numeric vectors. JSON integer array contains value larger R’s 32-bit integer representation, array transformed R numeric vector. NOTE results loss precision JSON integer values greater 2^53. JSON objects transformed R named lists. several additional details. JSON scalar JSON vector length 1 represented way R. JSON arrays mixing types integer double transformed R lists JSON null values represented R NULL values; arrays null transformed lists Ordering object members controlled object_names= argument. default preserves names appear JSON definition; use \"sort\" sort names alphabetically. argument applied recursively. parser corresponds approximately jsonlite::fromJSON() arguments simplifyVector = TRUE, simplifyDataFrame = FALSE, simplifyMatrix = FALSE). Unit tests (using tinytest framework) providing additional details available ","code":"as_r('{\"a\": 1.0, \"b\": [2, 3, 4]}') |>     str() #> List of 2 #>  $ a: num 1 #>  $ b: int [1:3] 2 3 4 as_r('[true, false, true]') # boolean -> logical ## [1]  TRUE FALSE  TRUE as_r('[1, 2, 3]')           # integer -> integer ## [1] 1 2 3 as_r('[1.0, 2.0, 3.0]')     # double  -> numeric ## [1] 1 2 3 as_r('[\"a\", \"b\", \"c\"]')     # string  -> character ## [1] \"a\" \"b\" \"c\" as_r('[1, 2.0]') |> class() # numeric ## [1] \"numeric\" as_r('[1, 2147483648]') |> class()  # 64-bit integers -> numeric ## [1] \"numeric\" as_r('{}') ## named list() as_r('{\"a\": 1.0, \"b\": [2, 3, 4]}') |> str() ## List of 2 ##  $ a: num 1 ##  $ b: int [1:3] 2 3 4 identical(as_r(\"3.14\"), as_r(\"[3.14]\")) ## [1] TRUE as_r('[true, 1, \"a\"]') |> str() ## List of 3 ##  $ : logi TRUE ##  $ : int 1 ##  $ : chr \"a\" as_r('null')                  # NULL ## NULL as_r('[null]') |> str()       # list(NULL) ## List of 1 ##  $ : NULL as_r('[null, null]') |> str() # list(NULL, NULL) ## List of 2 ##  $ : NULL ##  $ : NULL json <- '{\"b\": 1, \"a\": {\"d\": 2, \"c\": 3}}' as_r(json) |> str() ## List of 2 ##  $ b: int 1 ##  $ a:List of 2 ##   ..$ d: int 2 ##   ..$ c: int 3 as_r(json, object_names = \"sort\") |> str() ## List of 2 ##  $ a:List of 2 ##   ..$ c: int 3 ##   ..$ d: int 2 ##  $ b: int 1 system.file(package = \"rjsoncons\", \"tinytest\", \"test_as_r.R\")"},{"path":"https://mtmorgan.github.io/rjsoncons/articles/a_rjsoncons.html","id":"using-jsonlitefromjson","dir":"Articles","previous_headings":"The JSON parser","what":"Using jsonlite::fromJSON()","title":"Using 'jsoncons' in R","text":"built-parser can replaced alternative parsers returning query JSON string, e.g., using fromJSON() jsonlite package. rjsoncons package particularly useful accessing elements might otherwise require complicated application nested lapply(), purrr expressions, tidyr unnest_*() (see R Data Science chapter ‘Hierarchical data’).","code":"j_query(json, \"locations[?state == 'WA']\") |>     ## `fromJSON()` simplifies list-of-objects to data.frame     jsonlite::fromJSON() ## NULL"},{"path":"https://mtmorgan.github.io/rjsoncons/articles/a_rjsoncons.html","id":"c-library-use-in-other-packages","dir":"Articles","previous_headings":"","what":"C++ library use in other packages","title":"Using 'jsoncons' in R","text":"package includes complete ‘jsoncons’ C++ header-library, available R packages adding DESCRIPTION file. Typical use R package also include LinkingTo: specifications cpp11 Rcpp (package uses cpp11) packages provide C / C++ interface R C++ ‘jsoncons’ library.","code":"LinkingTo: rjsoncons SystemRequirements: C++11"},{"path":"https://mtmorgan.github.io/rjsoncons/articles/a_rjsoncons.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session information","title":"Using 'jsoncons' in R","text":"vignette compiled using following software versions","code":"sessionInfo() ## R version 4.3.2 (2023-10-31) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 22.04.3 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 ##  ## locale: ##  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        ##  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    ##  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           ## [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    ##  ## time zone: UTC ## tzcode source: system (glibc) ##  ## attached base packages: ## [1] stats     graphics  grDevices utils     datasets  methods   base      ##  ## other attached packages: ## [1] rjsoncons_1.2.0  BiocStyle_2.30.0 ##  ## loaded via a namespace (and not attached): ##  [1] vctrs_0.6.5         cli_3.6.2           knitr_1.45          ##  [4] rlang_1.1.3         xfun_0.41           stringi_1.8.3       ##  [7] purrr_1.0.2         textshaping_0.3.7   jsonlite_1.8.8      ## [10] glue_1.7.0          htmltools_0.5.7     ragg_1.2.7          ## [13] sass_0.4.8          rmarkdown_2.25      evaluate_0.23       ## [16] jquerylib_0.1.4     fastmap_1.1.1       yaml_2.3.8          ## [19] lifecycle_1.0.4     memoise_2.0.1       bookdown_0.37       ## [22] BiocManager_1.30.22 stringr_1.5.1       compiler_4.3.2      ## [25] fs_1.6.3            systemfonts_1.0.5   digest_0.6.34       ## [28] R6_2.5.1            magrittr_2.0.3      bslib_0.6.1         ## [31] tools_4.3.2         pkgdown_2.0.7       cachem_1.0.8        ## [34] desc_1.4.3"},{"path":"https://mtmorgan.github.io/rjsoncons/articles/b_ndjson_extended.html","id":"installation-setup","dir":"Articles","previous_headings":"","what":"Installation & setup","title":"Processing NDJSON","text":"article assumes rjsoncons, [listviewer][] (interactively exploring JSON), dplyr (manipulating results tibble) [tidyr][] (unnesting columns tibble) cli (providing progress indicator) installed. Start loading rjsoncons dplyr packages current session. use data GH Archive, project record activity public GitHub repositories. Create location file system-wide ‘cache’ directory rjsoncons package. necessary, download single file (1 hour activity, 170,000 events, 100 Mb) GH Archive.","code":"pkgs <- c(\"rjsoncons\", \"dplyr\", \"tidyr\", \"cli\") needed <- pkgs[!pkgs %in% rownames(installed.packages())] install.packages(needed, repos = \"https://CRAN.R-project.org\") library(rjsoncons) library(dplyr) cache <- tools::R_user_dir(\"rjsoncons\", \"cache\") if (!dir.exists(cache))     dir.create(cache, recursive = TRUE) archive_file <- \"https://data.gharchive.org/2023-02-08-0.json.gz\" ndjson_file <- file.path(cache, \"2023-02-08-0.json.gz\") if (!file.exists(ndjson_file))     download.file(archive_file, ndjson_file)"},{"path":"https://mtmorgan.github.io/rjsoncons/articles/b_ndjson_extended.html","id":"data-exploration","dir":"Articles","previous_headings":"","what":"Data exploration","title":"Processing NDJSON","text":"Ensure ndjson_file defined exists get sense data, read visualize first record query uses default path = \"@\", JMESpath expression returns current element. n_records = argument available processing NDJSON, restricts number records input. useful exploring data. record contains information . Records general structure, information can differ, e.g., actions org field. work \"id\" \"type\" top-level fields, available using JMESpath elaborate query might combine , nested, elements, e.g., Note records 3-5 organization.","code":"stopifnot(     file.exists(ndjson_file) ) j_query(ndjson_file, n_records = 1) |>     listviewer::jsonedit() {   \"id\": \"26939254345\",   \"type\": \"DeleteEvent\",   \"actor\": {     \"id\": 19908762,     \"login\": \"lucianHymer\",     \"display_login\": \"lucianHymer\",     \"gravatar_id\": \"\",     \"url\": \"https://api.github.com/users/lucianHymer\",     \"avatar_url\": \"https://avatars.githubusercontent.com/u/19908762?\"   },   \"repo\": {     \"id\": 469847426,     \"name\": \"gitcoinco/passport\",     \"url\": \"https://api.github.com/repos/gitcoinco/passport\"   },   \"payload\": {     \"ref\": \"format-alert-messages\",     \"ref_type\": \"branch\",     \"pusher_type\": \"user\"   },   \"public\": true,   \"created_at\": \"2023-02-08T00:00:00Z\",   \"org\": {     \"id\": 30044474,     \"login\": \"gitcoinco\",     \"gravatar_id\": \"\",     \"url\": \"https://api.github.com/orgs/gitcoinco\",     \"avatar_url\": \"https://avatars.githubusercontent.com/u/30044474?\"   } } j_query(ndjson_file, '{id: id, type: type}', n_records = 5) ## [1] \"{\\\"id\\\":\\\"26939254345\\\",\\\"type\\\":\\\"DeleteEvent\\\"}\" ## [2] \"{\\\"id\\\":\\\"26939254358\\\",\\\"type\\\":\\\"PushEvent\\\"}\"   ## [3] \"{\\\"id\\\":\\\"26939254361\\\",\\\"type\\\":\\\"CreateEvent\\\"}\" ## [4] \"{\\\"id\\\":\\\"26939254365\\\",\\\"type\\\":\\\"CreateEvent\\\"}\" ## [5] \"{\\\"id\\\":\\\"26939254366\\\",\\\"type\\\":\\\"PushEvent\\\"}\" j_query(ndjson_file, '{id: id, type: type, \"org.id\": org.id}', n_records = 5) ## [1] \"{\\\"id\\\":\\\"26939254345\\\",\\\"type\\\":\\\"DeleteEvent\\\",\\\"org.id\\\":30044474}\" ## [2] \"{\\\"id\\\":\\\"26939254358\\\",\\\"type\\\":\\\"PushEvent\\\",\\\"org.id\\\":123667276}\"  ## [3] \"{\\\"id\\\":\\\"26939254361\\\",\\\"type\\\":\\\"CreateEvent\\\",\\\"org.id\\\":null}\"     ## [4] \"{\\\"id\\\":\\\"26939254365\\\",\\\"type\\\":\\\"CreateEvent\\\",\\\"org.id\\\":null}\"     ## [5] \"{\\\"id\\\":\\\"26939254366\\\",\\\"type\\\":\\\"PushEvent\\\",\\\"org.id\\\":null}\""},{"path":"https://mtmorgan.github.io/rjsoncons/articles/b_ndjson_extended.html","id":"use-jmespath-for-queries","dir":"Articles","previous_headings":"Data exploration","what":"Use JMESpath for queries","title":"Processing NDJSON","text":"JMESpath seems appropriate working NDJSON files. ’s JMESpath query extracting just org information; query processes five records returns five results; records 3-5 key, \"null\". JSONpointer path used, error key exist, third record processed Also, JSONpointer allow one create new objects components data, one assemble id type keys original object new object. JSONpath allows missing keys straight-forward assemble new objects, e.g., placing top-level \"id\" \"type\" keys single object.","code":"j_query(ndjson_file, 'org', n_records = 5) ## [1] \"{\\\"id\\\":30044474,\\\"login\\\":\\\"gitcoinco\\\",\\\"gravatar_id\\\":\\\"\\\",\\\"url\\\":\\\"https://api.github.com/orgs/gitcoinco\\\",\\\"avatar_url\\\":\\\"https://avatars.githubusercontent.com/u/30044474?\\\"}\"                     ## [2] \"{\\\"id\\\":123667276,\\\"login\\\":\\\"johnbieren-testing\\\",\\\"gravatar_id\\\":\\\"\\\",\\\"url\\\":\\\"https://api.github.com/orgs/johnbieren-testing\\\",\\\"avatar_url\\\":\\\"https://avatars.githubusercontent.com/u/123667276?\\\"}\" ## [3] \"null\"                                                                                                                                                                                                      ## [4] \"null\"                                                                                                                                                                                                      ## [5] \"null\" try(     ## fails: 'b' does not exist     j_query('{\"a\": 1}', '/b') ) ## Error : Key not found  try(     ## fails: record 3 does not have 'org' key     j_query(ndjson_file, '/org', n_records = 5) ) ## Error : Key not found j_query(ndjson_file, \"$.org\", n_records = 5) ## [1] \"[{\\\"id\\\":30044474,\\\"login\\\":\\\"gitcoinco\\\",\\\"gravatar_id\\\":\\\"\\\",\\\"url\\\":\\\"https://api.github.com/orgs/gitcoinco\\\",\\\"avatar_url\\\":\\\"https://avatars.githubusercontent.com/u/30044474?\\\"}]\"                     ## [2] \"[{\\\"id\\\":123667276,\\\"login\\\":\\\"johnbieren-testing\\\",\\\"gravatar_id\\\":\\\"\\\",\\\"url\\\":\\\"https://api.github.com/orgs/johnbieren-testing\\\",\\\"avatar_url\\\":\\\"https://avatars.githubusercontent.com/u/123667276?\\\"}]\" ## [3] \"[]\"                                                                                                                                                                                                          ## [4] \"[]\"                                                                                                                                                                                                          ## [5] \"[]\""},{"path":"https://mtmorgan.github.io/rjsoncons/articles/b_ndjson_extended.html","id":"use-tibble-with-j_pivot","dir":"Articles","previous_headings":"Data exploration","what":"Use tibble with j_pivot()","title":"Processing NDJSON","text":"j_pivot() useful extracting tabular data JSON NDJSON representations. Recall j_pivot() transforms JSON array file records objects object arrays can represented data.frame tibble ‘hood’, j_pivot() simply calling = \"R\" .data.frame() result. Unfortunately, .data.frame() fails keys translated NULL, e.g., org absent coercion R representation tibble robust missing data Hierarchical data chapter R Data Science suggests using tidyr::unnest_wider() tidyr::unnest_longer()` working nested data. result pivot can flattened one interested keys nested org element, incorporated directly path. Note keys containing . need quoted \"org.id\": org.id.","code":"path <- '{id: id, type: type}' j_pivot(ndjson_file, path, n_records = 5, as = \"R\") |>     str() ## List of 2 ##  $ id  : chr [1:5] \"26939254345\" \"26939254358\" \"26939254361\" \"26939254365\" ... ##  $ type: chr [1:5] \"DeleteEvent\" \"PushEvent\" \"CreateEvent\" \"CreateEvent\" ... j_pivot(ndjson_file, path, n_records = 5, as = \"data.frame\") ##            id        type ## 1 26939254345 DeleteEvent ## 2 26939254358   PushEvent ## 3 26939254361 CreateEvent ## 4 26939254365 CreateEvent ## 5 26939254366   PushEvent path <- '{id: id, type: type, org: org}' try(     j_pivot(ndjson_file, path, n_records = 5, as = \"data.frame\") ) ## Error in (function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE,  :  ##   arguments imply differing number of rows: 1, 0 tbl <- j_pivot(ndjson_file, path, n_records = 5, as = \"tibble\") tbl ## # A tibble: 5 × 3 ##   id          type        org              ##   <chr>       <chr>       <list>           ## 1 26939254345 DeleteEvent <named list [5]> ## 2 26939254358 PushEvent   <named list [5]> ## 3 26939254361 CreateEvent <NULL>           ## 4 26939254365 CreateEvent <NULL>           ## 5 26939254366 PushEvent   <NULL> tbl |>     tidyr::unnest_wider(\"org\", names_sep = \".\") ## # A tibble: 5 × 7 ##   id          type       org.id org.login org.gravatar_id org.url org.avatar_url ##   <chr>       <chr>       <int> <chr>     <chr>           <chr>   <chr>          ## 1 26939254345 DeleteEv…  3.00e7 gitcoinco \"\"              https:… https://avata… ## 2 26939254358 PushEvent  1.24e8 johnbier… \"\"              https:… https://avata… ## 3 26939254361 CreateEv… NA      NA        NA              NA      NA             ## 4 26939254365 CreateEv… NA      NA        NA              NA      NA             ## 5 26939254366 PushEvent NA      NA        NA              NA      NA path <- '{id: id, type: type, \"org.id\": org.id}' j_pivot(ndjson_file, path, n_records = 5, as = \"tibble\") ## # A tibble: 5 × 3 ##   id          type        org.id    ##   <chr>       <chr>       <list>    ## 1 26939254345 DeleteEvent <int [1]> ## 2 26939254358 PushEvent   <int [1]> ## 3 26939254361 CreateEvent <NULL>    ## 4 26939254365 CreateEvent <NULL>    ## 5 26939254366 PushEvent   <NULL>"},{"path":"https://mtmorgan.github.io/rjsoncons/articles/b_ndjson_extended.html","id":"filters-with-jmespath","dir":"Articles","previous_headings":"Data exploration","what":"Filters with JMESpath","title":"Processing NDJSON","text":"strategy filtering NDJSON JMESpath create length 1 array containing object interest, filter array. Thus discover PushEvents organizations, form array object containing relevant information [{id: id, type: type, org: org}] filter array using JMESpath’s query syntax [?@.type == 'PushEvent' && org != null]. type quotation (single-quote, ') important query, use double quotes define path j_pivot() removes empty records","code":"path <- \"[{id: id, type: type, org: org}][?@.type == 'PushEvent' && org != null]\" j_query(ndjson_file, path, n_records = 5) ## [1] \"[]\"                                                                                                                                                                                                                                                                  ## [2] \"[{\\\"id\\\":\\\"26939254358\\\",\\\"type\\\":\\\"PushEvent\\\",\\\"org\\\":{\\\"id\\\":123667276,\\\"login\\\":\\\"johnbieren-testing\\\",\\\"gravatar_id\\\":\\\"\\\",\\\"url\\\":\\\"https://api.github.com/orgs/johnbieren-testing\\\",\\\"avatar_url\\\":\\\"https://avatars.githubusercontent.com/u/123667276?\\\"}}]\" ## [3] \"[]\"                                                                                                                                                                                                                                                                  ## [4] \"[]\"                                                                                                                                                                                                                                                                  ## [5] \"[]\" path <- \"[{id: id, type: type, org: org}][?@.type == 'PushEvent' && org != null]\" j_pivot(ndjson_file, path, n_records = 5, as = \"tibble\") ## # A tibble: 1 × 3 ##   id          type      org              ##   <chr>       <chr>     <list>           ## 1 26939254358 PushEvent <named list [5]>"},{"path":"https://mtmorgan.github.io/rjsoncons/articles/b_ndjson_extended.html","id":"performance","dir":"Articles","previous_headings":"","what":"Performance","title":"Processing NDJSON","text":"rjsoncons relatively performant processing large files. Use verbose = TRUE get progress indicators. system, takes approximately 13s. Memory use extensive, R level file processed chunks final result represented R data structures. performance rjsoncons comparable purpose-built jq command-line tool. jq takes 9s run command line. additional 3s required input command-line output R. jq provides greater flexibility JMESpath, widely used. use case outlined compares favorably performance ndjson CRAN package, took 600s complete task . ndjson reads entire data set R, whereas rjsoncons represents final object columns id type R. DuckDB offers CRAN package supports SQL interface JSON, performant. following code takes just 3.7s deliver data.frame R. DuckDB SQL interface allows flexible selection, filtering, data summary. also treats collection JSON files single ‘database’, scales favorably automatically number files processed. DuckDB require additional software, duckdb CRAN package blog post provides additional details comparison solutions, including discussion design decisions rjsoncons adopted achieve reasonable performance.","code":"system.time({     tbl <- j_pivot(         ndjson_file, '{id: id, type: type}',         as = \"tibble\", verbose = TRUE     ) }) ## 0 records processed ## 24830 records processed ## 56291 records processed ## 87811 records processed ## 119566 records processed ## 152195 records processed ## 172049 records processed ##    user  system elapsed  ##  16.161   0.046  16.208 tbl ## # A tibble: 172,049 × 2 ##    id          type        ##    <chr>       <chr>       ##  1 26939254345 DeleteEvent ##  2 26939254358 PushEvent   ##  3 26939254361 CreateEvent ##  4 26939254365 CreateEvent ##  5 26939254366 PushEvent   ##  6 26939254367 PushEvent   ##  7 26939254379 PushEvent   ##  8 26939254380 IssuesEvent ##  9 26939254382 PushEvent   ## 10 26939254383 PushEvent   ## # ℹ 172,039 more rows tbl |>     count(type, sort = TRUE) ## # A tibble: 15 × 2 ##    type                              n ##    <chr>                         <int> ##  1 PushEvent                     90250 ##  2 CreateEvent                   25311 ##  3 PullRequestEvent              18326 ##  4 IssueCommentEvent              9610 ##  5 DeleteEvent                    9065 ##  6 WatchEvent                     5620 ##  7 PullRequestReviewEvent         3823 ##  8 IssuesEvent                    2744 ##  9 PullRequestReviewCommentEvent  2098 ## 10 ForkEvent                      1900 ## 11 CommitCommentEvent             1257 ## 12 ReleaseEvent                    917 ## 13 PublicEvent                     491 ## 14 MemberEvent                     388 ## 15 GollumEvent                     249 library(glue) library(duckdb) library(DBI)  con <- dbConnect(duckdb()) dbExecute(con, \"INSTALL 'json';\") # only required once dbExecute(con, \"LOAD 'json';\")  sql <- glue(     \"SELECT id, type      FROM read_ndjson_auto('{ndjson_file}');\" )  system.time({     res <- dbGetQuery(con, sql) }) # 3.7 seconds!"},{"path":"https://mtmorgan.github.io/rjsoncons/articles/b_ndjson_extended.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session information","title":"Processing NDJSON","text":"","code":"sessionInfo() ## R version 4.3.2 (2023-10-31) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 22.04.3 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 ##  ## locale: ##  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        ##  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    ##  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           ## [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    ##  ## time zone: UTC ## tzcode source: system (glibc) ##  ## attached base packages: ## [1] stats     graphics  grDevices utils     datasets  methods   base      ##  ## other attached packages: ## [1] dplyr_1.1.4      rjsoncons_1.2.0  BiocStyle_2.30.0 ##  ## loaded via a namespace (and not attached): ##  [1] jsonlite_1.8.8      compiler_4.3.2      BiocManager_1.30.22 ##  [4] tidyselect_1.2.0    stringr_1.5.1       tidyr_1.3.1         ##  [7] jquerylib_0.1.4     systemfonts_1.0.5   textshaping_0.3.7   ## [10] yaml_2.3.8          fastmap_1.1.1       R6_2.5.1            ## [13] generics_0.1.3      knitr_1.45          tibble_3.2.1        ## [16] bookdown_0.37       desc_1.4.3          bslib_0.6.1         ## [19] pillar_1.9.0        rlang_1.1.3         utf8_1.2.4          ## [22] cachem_1.0.8        stringi_1.8.3       xfun_0.41           ## [25] fs_1.6.3            sass_0.4.8          memoise_2.0.1       ## [28] cli_3.6.2           withr_3.0.0         pkgdown_2.0.7       ## [31] magrittr_2.0.3      digest_0.6.34       lifecycle_1.0.4     ## [34] vctrs_0.6.5         evaluate_0.23       glue_1.7.0          ## [37] ragg_1.2.7          fansi_1.0.6         rmarkdown_2.25      ## [40] purrr_1.0.2         tools_4.3.2         pkgconfig_2.0.3     ## [43] htmltools_0.5.7"},{"path":"https://mtmorgan.github.io/rjsoncons/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Martin Morgan. Author, maintainer. Marcel Ramos. Author. Daniel Parker. Author, copyright holder.            jsoncons C++ library maintainer","code":""},{"path":"https://mtmorgan.github.io/rjsoncons/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Morgan M, Ramos M, Parker D (2024). rjsoncons: 'C++' Header-'jsoncons' Library 'JSON' Queries. R package version 1.2.0, https://mtmorgan.github.io/rjsoncons/.","code":"@Manual{,   title = {rjsoncons: 'C++' Header-Only 'jsoncons' Library for 'JSON' Queries},   author = {Martin Morgan and Marcel Ramos and Daniel Parker},   year = {2024},   note = {R package version 1.2.0},   url = {https://mtmorgan.github.io/rjsoncons/}, }"},{"path":"https://mtmorgan.github.io/rjsoncons/index.html","id":"rjsoncons","dir":"","previous_headings":"","what":"C++ Header-Only jsoncons Library for JSON Queries","title":"C++ Header-Only jsoncons Library for JSON Queries","text":"jsoncons C++ header-library constructs representations JSON character vector, provides extensions flexible queries operations JSON objects. package provides ‘R’ functions query (filter transform) pivot (convert array--objects object--arrays, easy import ‘R’) ‘JSON’ ‘NDJSON’ strings files using JSONpath, JMESpath, JSONpointer expressions. package also makes easy use C++ ‘jsoncons’ R packages direct access ‘C++’ functionality.","code":""},{"path":"https://mtmorgan.github.io/rjsoncons/index.html","id":"installation-and-loading","dir":"","previous_headings":"","what":"Installation and loading","title":"C++ Header-Only jsoncons Library for JSON Queries","text":"Install released package version CRAN Install development version Attach installed package R session ","code":"install.packages(\"rjsoncons\", repos = \"https://CRAN.R-project.org\") if (!requireNamespace(\"remotes\", quiety = TRUE))     install.packages(\"remotes\", repos = \"https://CRAN.R-project.org\") remotes::install_github(\"mtmorgan/rjsoncons\") library(rjsoncons)"},{"path":"https://mtmorgan.github.io/rjsoncons/index.html","id":"use-cases","dir":"","previous_headings":"","what":"Use cases","title":"C++ Header-Only jsoncons Library for JSON Queries","text":"introductory vignette outlines common use cases, including: Filtering large JSON documents extract records interest. Extracting deeply nested elements. Transforming data direct incorporation R data structures. jsoncons C++ header-library useful starting point advanced JSON manipulation. vignette outlines rjsoncons can used R packages wishing access C++ library.","code":""},{"path":"https://mtmorgan.github.io/rjsoncons/index.html","id":"next-steps","dir":"","previous_headings":"","what":"Next steps","title":"C++ Header-Only jsoncons Library for JSON Queries","text":"See introductory vignette additional details.","code":""},{"path":"https://mtmorgan.github.io/rjsoncons/reference/as_r.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse JSON to R — as_r","title":"Parse JSON to R — as_r","text":"as_r() transforms JSON string R object.","code":""},{"path":"https://mtmorgan.github.io/rjsoncons/reference/as_r.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse JSON to R — as_r","text":"","code":"as_r(data, object_names = \"asis\", ...)"},{"path":"https://mtmorgan.github.io/rjsoncons/reference/as_r.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parse JSON to R — as_r","text":"data character(1) JSON string (unusually) R object. object_names character(1) order data object elements \"asis\" (default) \"sort\" filtering path. ... passed jsonlite::toJSON() unusual circumstance data R object.","code":""},{"path":"https://mtmorgan.github.io/rjsoncons/reference/as_r.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parse JSON to R — as_r","text":"as_r() returns R object.","code":""},{"path":"https://mtmorgan.github.io/rjsoncons/reference/as_r.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parse JSON to R — as_r","text":"= \"R\" argument j_query(), j_pivot(), etc., as_r() function transform JSON string representation R object. Main rules : JSON arrays single type (boolean, integer, double, string) transformed R vectors length corresponding type. JSON scalar JSON vector length 1 represented way R. JSON 64-bit integer array contains value larger R's 32-bit integer representation, array transformed R numeric vector. NOTE results loss precision 64-bit integer values greater 2^53. JSON arrays mixing integer double values transformed R numeric vectors. JSON objects transformed R named lists. vignette reiterates information provides additional details.","code":""},{"path":"https://mtmorgan.github.io/rjsoncons/reference/as_r.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parse JSON to R — as_r","text":"","code":"## as_r() as_r('[1, 2, 3]')       # JSON integer array -> R integer vector #> [1] 1 2 3 as_r('[1, 2.0, 3]')     # JSON intger and double array -> R numeric vector #> [1] 1 2 3 as_r('[1, 2.0, \"3\"]')   # JSON mixed array -> R list #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>  #> [[3]] #> [1] \"3\" #>  as_r('[1, 2147483648]') # JSON integer > R integer max -> R numeric vector #> [1]          1 2147483648  json <- '{\"b\": 1, \"a\": [\"c\", \"d\"], \"e\": true, \"f\": [true], \"g\": {}}' as_r(json) |> str()     # parsing complex objects #> List of 5 #>  $ b: int 1 #>  $ a: chr [1:2] \"c\" \"d\" #>  $ e: logi TRUE #>  $ f: logi TRUE #>  $ g: Named list() identical(              # JSON scalar and length 1 array identical in R     as_r('{\"a\": 1}'), as_r('{\"a\": [1]}') ) #> [1] TRUE"},{"path":"https://mtmorgan.github.io/rjsoncons/reference/j_data_type.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect JSON / NDJSON data and path types — j_data_type","title":"Detect JSON / NDJSON data and path types — j_data_type","text":"j_data_type() uses simple rules determine whether 'data' JSON, NDJSON, file, url, R. j_path_type() uses simple rules identify whether path JSONpointer, JSONpath, JMESpath expression.","code":""},{"path":"https://mtmorgan.github.io/rjsoncons/reference/j_data_type.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect JSON / NDJSON data and path types — j_data_type","text":"","code":"j_data_type(data)  j_path_type(path)"},{"path":"https://mtmorgan.github.io/rjsoncons/reference/j_data_type.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detect JSON / NDJSON data and path types — j_data_type","text":"data character() JSON string NDJSON records, R object parsed JSON string using jsonlite::toJSON(). path character(1) JSONpointer, JSONpath JMESpath query string.","code":""},{"path":"https://mtmorgan.github.io/rjsoncons/reference/j_data_type.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Detect JSON / NDJSON data and path types — j_data_type","text":"j_data_type() without arguments reports possible return values: \"json\", \"ndjson\", \"file\", \"url\", \"R\".  provided argument, j_data_type() infers (validate) type data based following rules: scalar (length 1) character data, either \"url\" (matching regular expression \"^https?://\", \"file\" (file.exists(data) returns TRUE), \"json\". \"file\" \"url\" inferred, return value length 2 vector, first element inferred type data (\"json\" \"ndjson\") obtained first 2 lines file. character data length(data) > 1, \"ndjson\" elements start square bracket curly brace, consistently (.e., agreeing start first record), otherwise \"json\". \"R\" non-character data. j_path_type() without argument reports possible values: \"JSONpointer\", \"JSONpath\", \"JMESpath\". provided argument, j_path_type() infers type path using simple incomplete classification: \"JSONpointer\" inferred path \"\" starts \"/\". \"JSONpath\" expressions start \"$\". \"JMESpath\" expressions satisfy neither JSONpointer JSONpath criteria. rules, valid JSONpointer path \"@\" interpreted JMESpath; use jsonpointer() JSONpointer behavior required.","code":""},{"path":"https://mtmorgan.github.io/rjsoncons/reference/j_data_type.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Detect JSON / NDJSON data and path types — j_data_type","text":"","code":"j_data_type()                            # available types #> [[1]] #> [1] \"json\" #>  #> [[2]] #> [1] \"ndjson\" #>  #> [[3]] #> [1] \"json\" \"file\" #>  #> [[4]] #> [1] \"ndjson\" \"file\"   #>  #> [[5]] #> [1] \"json\" \"url\"  #>  #> [[6]] #> [1] \"ndjson\" \"url\"    #>  #> [[7]] #> [1] \"R\" #>  j_data_type(\"\")                          # json #> [1] \"R\" j_data_type('{\"a\": 1}')                  # json #> [1] \"json\" j_data_type(c('[{\"a\": 1}', '{\"a\": 2}]')) # json #> [1] \"json\" j_data_type(c('{\"a\": 1}', '{\"a\": 2}'))   # ndjson #> [1] \"ndjson\" j_data_type(list(a = 1, b = 2))          # R #> [1] \"R\" fl <- system.file(package = \"rjsoncons\", \"extdata\", \"example.json\") j_data_type(fl)                          # c('json', 'file') #> [1] \"json\" \"file\" j_data_type(readLines(fl))               # json #> [1] \"json\"  j_path_type()                            # available types #> [1] \"JSONpointer\" \"JSONpath\"    \"JMESpath\"    j_path_type(\"\")                          # JSONpointer #> [1] \"JSONpointer\" j_path_type(\"/locations/0/name\")         # JSONpointer #> [1] \"JSONpointer\" j_path_type(\"$.locations[0].name\")       # JSONpath #> [1] \"JSONpath\" j_path_type(\"locations[0].name\")         # JMESpath #> [1] \"JMESpath\""},{"path":"https://mtmorgan.github.io/rjsoncons/reference/j_query.html","id":null,"dir":"Reference","previous_headings":"","what":"Query and pivot for JSON / NDJSON documents — j_query","title":"Query and pivot for JSON / NDJSON documents — j_query","text":"j_query() executes query JSON NDJSON document, automatically inferring type data path. j_pivot() transforms JSON array--objects object--arrays; can useful forming column-based tibble row-oriented JSON.","code":""},{"path":"https://mtmorgan.github.io/rjsoncons/reference/j_query.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Query and pivot for JSON / NDJSON documents — j_query","text":"","code":"j_query(   data,   path = \"\",   object_names = \"asis\",   as = \"string\",   ...,   data_type = j_data_type(data),   path_type = j_path_type(path) )  j_pivot(   data,   path = \"\",   object_names = \"asis\",   as = \"string\",   ...,   data_type = j_data_type(data),   path_type = j_path_type(path) )"},{"path":"https://mtmorgan.github.io/rjsoncons/reference/j_query.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Query and pivot for JSON / NDJSON documents — j_query","text":"data character() JSON string NDJSON records, R object parsed JSON string using jsonlite::toJSON(). path character(1) JSONpointer, JSONpath JMESpath query string. object_names character(1) order data object elements \"asis\" (default) \"sort\" filtering path. character(1) return type. j_query(), \"string\" returns JSON / NDJSON strings; \"R\" parses JSON / NDJSON R using rules as_r(). j_pivot() (JSON ), use = \"data.frame\" = \"tibble\" coerce result data.frame tibble. ... arguments parsing NDJSON, passed jsonlite::toJSON data character-valued. NDJSON, Use n_records = 2 parse just first two records NDJSON document. Use verbose = TRUE obtain progress bar reading connection (file URL). Requires cli package. example use jsonlite::toJSON() use auto_unbox = TRUE automatically 'unbox' vectors length 1 JSON scalar values. data_type character(1) type data; one \"json\", \"ndjson\". Inferred data using j_data_type(). path_type character(1) type path; one \"JSONpointer\", \"JSONpath\", \"JMESpath\". Inferred path using j_path_type().","code":""},{"path":"https://mtmorgan.github.io/rjsoncons/reference/j_query.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Query and pivot for JSON / NDJSON documents — j_query","text":"j_pivot() transforms 'array--objects' (typical JSON row-oriented representation table) 'object--arrays'. simple example transforms array two objects three fields '[{\"\": 1, \"b\": 2, \"c\": 3}, {\"\": 4, \"b\": 5, \"c\": 6}]' object three fields, vector length 2 '{\"\": [1, 4], \"b\": [2, 5], \"c\": [3, 6]}'. object--arrays representation corresponds closely R data.frame tibble, illustrated examples. j_pivot() JMESpath paths especially useful transforming NDJSON data.frame tibble","code":""},{"path":"https://mtmorgan.github.io/rjsoncons/reference/j_query.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Query and pivot for JSON / NDJSON documents — j_query","text":"","code":"json <- '{   \"locations\": [     {\"name\": \"Seattle\", \"state\": \"WA\"},     {\"name\": \"New York\", \"state\": \"NY\"},     {\"name\": \"Bellevue\", \"state\": \"WA\"},     {\"name\": \"Olympia\", \"state\": \"WA\"}   ] }'  j_query(json, \"/locations/0/name\")             # JSONpointer #> [1] \"Seattle\" j_query(json, \"$.locations[*].name\", as = \"R\") # JSONpath #> [1] \"Seattle\"  \"New York\" \"Bellevue\" \"Olympia\"  j_query(json, \"locations[].state\", as = \"R\")   # JMESpath #> [1] \"WA\" \"NY\" \"WA\" \"WA\"  ## a few NDJSON records from <https://www.gharchive.org/> ndjson_file <-     system.file(package = \"rjsoncons\", \"extdata\", \"2023-02-08-0.json\") j_query(ndjson_file, \"{id: id, type: type}\") #>  [1] \"{\\\"id\\\":\\\"26939254345\\\",\\\"type\\\":\\\"DeleteEvent\\\"}\" #>  [2] \"{\\\"id\\\":\\\"26939254358\\\",\\\"type\\\":\\\"PushEvent\\\"}\"   #>  [3] \"{\\\"id\\\":\\\"26939254361\\\",\\\"type\\\":\\\"CreateEvent\\\"}\" #>  [4] \"{\\\"id\\\":\\\"26939254365\\\",\\\"type\\\":\\\"CreateEvent\\\"}\" #>  [5] \"{\\\"id\\\":\\\"26939254366\\\",\\\"type\\\":\\\"PushEvent\\\"}\"   #>  [6] \"{\\\"id\\\":\\\"26939254367\\\",\\\"type\\\":\\\"PushEvent\\\"}\"   #>  [7] \"{\\\"id\\\":\\\"26939254379\\\",\\\"type\\\":\\\"PushEvent\\\"}\"   #>  [8] \"{\\\"id\\\":\\\"26939254380\\\",\\\"type\\\":\\\"IssuesEvent\\\"}\" #>  [9] \"{\\\"id\\\":\\\"26939254382\\\",\\\"type\\\":\\\"PushEvent\\\"}\"   #> [10] \"{\\\"id\\\":\\\"26939254383\\\",\\\"type\\\":\\\"PushEvent\\\"}\"    j_pivot(json, \"$.locations[?@.state=='WA']\", as = \"string\") #> [1] \"{\\\"name\\\":[\\\"Seattle\\\",\\\"Bellevue\\\",\\\"Olympia\\\"],\\\"state\\\":[\\\"WA\\\",\\\"WA\\\",\\\"WA\\\"]}\" j_pivot(json, \"locations[?@.state=='WA']\", as = \"R\") #> $name #> [1] \"Seattle\"  \"Bellevue\" \"Olympia\"  #>  #> $state #> [1] \"WA\" \"WA\" \"WA\" #>  j_pivot(json, \"locations[?@.state=='WA']\", as = \"data.frame\") #>       name state #> 1  Seattle    WA #> 2 Bellevue    WA #> 3  Olympia    WA j_pivot(json, \"locations[?@.state=='WA']\", as = \"tibble\") #> # A tibble: 3 × 2 #>   name     state #>   <chr>    <chr> #> 1 Seattle  WA    #> 2 Bellevue WA    #> 3 Olympia  WA     ## use 'path' to pivot ndjson one record at at time j_pivot(ndjson_file, \"{id: id, type: type}\", as = \"data.frame\") #>             id        type #> 1  26939254345 DeleteEvent #> 2  26939254358   PushEvent #> 3  26939254361 CreateEvent #> 4  26939254365 CreateEvent #> 5  26939254366   PushEvent #> 6  26939254367   PushEvent #> 7  26939254379   PushEvent #> 8  26939254380 IssuesEvent #> 9  26939254382   PushEvent #> 10 26939254383   PushEvent  ## 'org' is a nested element; extract it j_pivot(ndjson_file, \"org\", as = \"data.frame\") #>          id              login gravatar_id #> 1  30044474          gitcoinco             #> 2 123667276 johnbieren-testing             #> 3 123277977       CMPUT404-W23             #> 4 120284018       mornystannit             #>                                              url #> 1          https://api.github.com/orgs/gitcoinco #> 2 https://api.github.com/orgs/johnbieren-testing #> 3       https://api.github.com/orgs/CMPUT404-W23 #> 4       https://api.github.com/orgs/mornystannit #>                                           avatar_url #> 1  https://avatars.githubusercontent.com/u/30044474? #> 2 https://avatars.githubusercontent.com/u/123667276? #> 3 https://avatars.githubusercontent.com/u/123277977? #> 4 https://avatars.githubusercontent.com/u/120284018?  ## use j_pivot() to filter 'PushEvent' for organizations path <- \"[{id: id, type: type, org: org}]              [?@.type == 'PushEvent' && @.org != null]\" j_pivot(ndjson_file, path, as = \"data.frame\") #>            id      type    org.id          org.login org.gravatar_id #> 1 26939254358 PushEvent 123667276 johnbieren-testing                 #> 2 26939254382 PushEvent 123667276 johnbieren-testing                 #>                                          org.url #> 1 https://api.github.com/orgs/johnbieren-testing #> 2 https://api.github.com/orgs/johnbieren-testing #>                                       org.avatar_url  org.id.1  org.login.1 #> 1 https://avatars.githubusercontent.com/u/123667276? 120284018 mornystannit #> 2 https://avatars.githubusercontent.com/u/123667276? 120284018 mornystannit #>   org.gravatar_id.1                                org.url.1 #> 1                   https://api.github.com/orgs/mornystannit #> 2                   https://api.github.com/orgs/mornystannit #>                                     org.avatar_url.1 #> 1 https://avatars.githubusercontent.com/u/120284018? #> 2 https://avatars.githubusercontent.com/u/120284018?  ## try also ## ##     j_pivot(ndjson_file, path, as = \"tibble\") |> ##         tidyr::unnest_wider(\"org\", names_sep = \".\")"},{"path":"https://mtmorgan.github.io/rjsoncons/reference/paths_and_pointer.html","id":null,"dir":"Reference","previous_headings":"","what":"JSONpath, JMESpath, or JSONpointer query of JSON / NDJSON documents — jsonpath","title":"JSONpath, JMESpath, or JSONpointer query of JSON / NDJSON documents — jsonpath","text":"jsonpath() executes query JSON string vector NDJSON entries using 'JSONpath' specification. jmespath() executes query JSON string using 'JMESpath' specification. jsonpointer() extracts element JSON string using 'JSON pointer' specification.","code":""},{"path":"https://mtmorgan.github.io/rjsoncons/reference/paths_and_pointer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"JSONpath, JMESpath, or JSONpointer query of JSON / NDJSON documents — jsonpath","text":"","code":"jsonpath(data, path, object_names = \"asis\", as = \"string\", ...)  jmespath(data, path, object_names = \"asis\", as = \"string\", ...)  jsonpointer(data, path, object_names = \"asis\", as = \"string\", ...)"},{"path":"https://mtmorgan.github.io/rjsoncons/reference/paths_and_pointer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"JSONpath, JMESpath, or JSONpointer query of JSON / NDJSON documents — jsonpath","text":"data character() JSON string NDJSON records, R object parsed JSON string using jsonlite::toJSON(). path character(1) JSONpointer, JSONpath JMESpath query string. object_names character(1) order data object elements \"asis\" (default) \"sort\" filtering path. character(1) return type. \"string\" returns single JSON string; \"R\" returns R object following rules outlined as_r(). ... arguments parsing NDJSON, passed jsonlite::toJSON data character-valued. NDJSON, Use n_records = 2 parse just first two records NDJSON document. Use verbose = TRUE obtain progress bar reading connection (file URL). Requires cli package. example use jsonlite::toJSON() use auto_unbox = TRUE automatically 'unbox' vectors length 1 JSON scalar values.","code":""},{"path":"https://mtmorgan.github.io/rjsoncons/reference/paths_and_pointer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"JSONpath, JMESpath, or JSONpointer query of JSON / NDJSON documents — jsonpath","text":"jsonpath(), jmespath() jsonpointer() return character(1) JSON string (= \"string\", default) R object (= \"R\") representing result query.","code":""},{"path":"https://mtmorgan.github.io/rjsoncons/reference/paths_and_pointer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"JSONpath, JMESpath, or JSONpointer query of JSON / NDJSON documents — jsonpath","text":"","code":"json <- '{   \"locations\": [     {\"name\": \"Seattle\", \"state\": \"WA\"},     {\"name\": \"New York\", \"state\": \"NY\"},     {\"name\": \"Bellevue\", \"state\": \"WA\"},     {\"name\": \"Olympia\", \"state\": \"WA\"}   ]  }'  ## return a JSON string jsonpath(json, \"$..name\") |>     cat(\"\\n\") #> [\"Seattle\",\"New York\",\"Bellevue\",\"Olympia\"]   ## return an R object jsonpath(json, \"$..name\", as = \"R\") #> [1] \"Seattle\"  \"New York\" \"Bellevue\" \"Olympia\"   ## create a list with state and name as scalar vectors lst <- jsonlite::fromJSON(json, simplifyVector = FALSE)  ## objects other than scalar character vectors are automatically ## coerced to JSON; use `auto_unbox = TRUE` to represent R scalar ## vectors in the object as JSON scalar vectors jsonpath(lst, \"$..name\", auto_unbox = TRUE) |>     cat(\"\\n\") #> [\"Seattle\",\"New York\",\"Bellevue\",\"Olympia\"]   ## a scalar character vector like \"Seattle\" is not valid JSON... try(jsonpath(\"Seattle\", \"$\")) #> Error : JSON syntax_error at line 1 and column 1 ## ...but a double-quoted string is jsonpath('\"Seattle\"', \"$\") #> [1] \"[\\\"Seattle\\\"]\"  ## use I(\"Seattle\") to coerce to a JSON object [\"Seattle\"] jsonpath(I(\"Seattle\"), \"$[0]\")      |> cat(\"\\n\") #> [\"Seattle\"]   ## different ordering of object names -- 'asis' (default) or 'sort' json_obj <- '{\"b\": \"1\", \"a\": \"2\"}' jsonpath(json_obj, \"$\")           |> cat(\"\\n\") #> [{\"b\":\"1\",\"a\":\"2\"}]  jsonpath(json_obj, \"$.*\")         |> cat(\"\\n\") #> [\"1\",\"2\"]  jsonpath(json_obj, \"$\", \"sort\")   |> cat(\"\\n\") #> [{\"a\":\"2\",\"b\":\"1\"}]  jsonpath(json_obj, \"$.*\", \"sort\") |> cat(\"\\n\") #> [\"2\",\"1\"]   path <- \"locations[?state == 'WA'].name | sort(@)\" jmespath(json, path) |>     cat(\"\\n\") #> [\"Bellevue\",\"Olympia\",\"Seattle\"]   ## original filter always fails, e.g., '[\"WA\"] != 'WA' jmespath(lst, path)  # empty result set, '[]' #> [1] \"[]\"  ## filter with unboxed state, and return unboxed name jmespath(lst, \"locations[?state[0] == 'WA'].name[0] | sort(@)\") |>     cat(\"\\n\") #> [\"Bellevue\",\"Olympia\",\"Seattle\"]   ## automatically unbox scalar values when creating the JSON string jmespath(lst, path, auto_unbox = TRUE) |>     cat(\"\\n\") #> [\"Bellevue\",\"Olympia\",\"Seattle\"]   ## jsonpointer 0-based arrays jsonpointer(json, \"/locations/0/name\") #> [1] \"Seattle\"  ## document root \"\", sort selected element keys jsonpointer('{\"b\": 0, \"a\": 1}', \"\", \"sort\", as = \"R\") |>     str() #> List of 2 #>  $ a: int 1 #>  $ b: int 0  ## 'Key not found' -- path '/' searches for a 0-length key try(jsonpointer('{\"b\": 0, \"a\": 1}', \"/\")) #> Error : Key not found"},{"path":"https://mtmorgan.github.io/rjsoncons/reference/version.html","id":null,"dir":"Reference","previous_headings":"","what":"Version of jsoncons C++ library — version","title":"Version of jsoncons C++ library — version","text":"version() reports version C++ jsoncons library use.","code":""},{"path":"https://mtmorgan.github.io/rjsoncons/reference/version.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Version of jsoncons C++ library — version","text":"","code":"version()"},{"path":"https://mtmorgan.github.io/rjsoncons/reference/version.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Version of jsoncons C++ library — version","text":"version() returns character(1) major.minor.patch version string .","code":""},{"path":"https://mtmorgan.github.io/rjsoncons/reference/version.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Version of jsoncons C++ library — version","text":"","code":"version() #> [1] \"0.173.2\""},{"path":"https://mtmorgan.github.io/rjsoncons/news/index.html","id":"rjsoncons-120","dir":"Changelog","previous_headings":"","what":"rjsoncons 1.2.0","title":"rjsoncons 1.2.0","text":"CRAN release: 2024-01-26 (1.1.0.9500) update documentation, include NDJSON-specific, web-vignette (1.1.0.9400) support NDJSON file / url connections (1.1.0.9300) implement j_query() (query without requiring path specification), j_pivot(), j_path_type(). Remove jsonpivot(). (1.1.0.9200) implement jsonpointer() querying JSON documents. (1.1.0.9100) update jsoncons library 173.2, relaxing compiler requirements c++11. (1.1.0.9000) implement jsonpivot() transform JSON array--objects object--arrays, common step representation data.frame.","code":""},{"path":"https://mtmorgan.github.io/rjsoncons/news/index.html","id":"rjsoncons-110","dir":"Changelog","previous_headings":"","what":"rjsoncons 1.1.0","title":"rjsoncons 1.1.0","text":"CRAN release: 2023-12-11 (1.1.0) CRAN release (1.0.1.9100) using jsonlite (e.g., ‘toJSON()’ parsing R objects) requires separate installation jsonlite. (1.0.1.9000) update jsoncons library 0.172.1; addresses segfault ‘fedora’ CRAN builder","code":""},{"path":"https://mtmorgan.github.io/rjsoncons/news/index.html","id":"rjsoncons-101","dir":"Changelog","previous_headings":"","what":"rjsoncons 1.0.1","title":"rjsoncons 1.0.1","text":"CRAN release: 2023-12-03 (1.0.1) CRAN release (1.0.0.9200) use pkgdown (1.0.0.9100) parse JSON R = \"R\" argument as_r()","code":""},{"path":"https://mtmorgan.github.io/rjsoncons/news/index.html","id":"rjsoncons-100","dir":"Changelog","previous_headings":"","what":"rjsoncons 1.0.0","title":"rjsoncons 1.0.0","text":"CRAN release: 2022-09-29 (1.0.0) initial CRAN release (0.0.99) pre-release version (0.0.3) support object names ordering ‘asis’ ‘sort’ (0.0.3) DESCRIPTION file updates: correct ‘Title:’ capitalization; avoid warnings misspellings (0.0.3) Add GitHub action rebuild README.md vignettes/rjsoncons.Rmd (0.0.2) jsoncons library update (0.0.2) support R object query addition JSON string (0.0.2) add unit tests (0.0.2) R minor C++ code refactoring (0.0.1) initial C++ / R implementation jmespath() / jsonpath()","code":""}]
